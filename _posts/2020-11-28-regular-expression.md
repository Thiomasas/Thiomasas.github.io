---
published: true
layout: single
title: "정규표현식 문법 정리"
classes: wide
category: etc
sidebar:
    nav: "etc" 
tags: 
  - 정규표현식
---

코딩을 할 때 문자열이 조건에 맞는지 체크를 해야할 때가 있다. 그런데 if문에 여러가지 조건을 밀어넣으려고 하다 보면 코드는 꼬일대로 꼬이고 조건들을 일일이 체크하는 것도 귀찮아진다. 그래서 이번 포스트에서는 정규표현식이라는 문법을 소개할 것이다.

## 사용법

웬만한 고급 프로그래밍 언어에서는 정규표현식을 지원한다. (아마 대부분의 언어는 RegExp, RegEx 등의 객체로 정의되어 있을 것이다.)

이 포스트에서는 블로그 주인이 자주 사용하는 언어인 JavaScript, C#의 경우를 다루어보겠다.

### JavaScript에서 사용하기

JavaScript에서는 정규식을 생성자 없이 변수에 바로 담을 수도 있고, 아니면 선언 즉시 문자열에 적용할 수 있다.

~~~js
// 테스트할 문자열
var str = "Hello World!"

// /와 / 사이에 조건을 넣으면 정규식이 된다.
var regex = /Hello/;

// 생성자로도 정규식을 생성할 수 있다.
regex = new RegExp("Hello");

// 문자열에 test 함수를 적용해보면 조건에 맞는지 boolean 형태로 반환된다.
console.log(regex.test(str));

// 선언 즉시 문자열에 적용할 수도 있다.
console.log(/Hello/.test(str));
~~~

### C#에서 사용하기

C#에서는 JavaScript와 달리 정규식을 생성자를 통해 만들어야 한다.

~~~cs
// 테스트할 문자열
string str = "Hello World!";

// 생성자로 정규식 객체를 생성할 수 있다.
Regex reg = new Regex(@"Hello");

// 문자열에 isMatch 함수를 적용해보면 조건에 맞는지 Boolean 형태로 반환된다.
Console.WriteLine(reg.isMatch(str));
~~~

## 용도

정규식 객체들은 대체로 문자열이 조건에 맞는지 검사하는 것 뿐만 아니라 문자열을 조건에 맞게 나누기, 아니면 문자열에서 조건에 맞는 문자열을 추출하기 등 여러 용도가 있다.

## 문법

정규식은 여러가지 조합을 사용할 수 있다. 사실 이 글을 쓰고 있는 입장에서도 문법이 기억나지 않는 경우가 많아서 글을 쓰게 된 것이니 복잡하긴 하다. 

먼저 간단한 단순 패턴을 사용해보자면 

~~~regex
/Hello/
~~~

이 패턴은 문자열에서 Hello라는 문자열을 찾는다.

조금 더 심화된 문법을 사용하려면 특수문자를 사용할 수 있다.

### 메타 문자

메타 문자는 특정 문자를 규칙으로 대체할 수 있다.

| 메타 문자 | 역할 |
| --- | --- |
| ^ | 문자열의 시작을 의미한다. [...] 안에서는 일치하지 않는다를 의미한다. |
| $ | 문자열의 끝을 의미한다. |
| \b | 단어의 경계에 대응된다. 공백, 탭, 컴마, 대시 등이 올 수 있다. b가 대문자인 경우 반대이다. |
| \s | 공백문자와 탭에 대응한다. s가 대문자인 경우 반대이다. |
| \d | 숫자에 대응된다. [0-9] 와 같다. d가 대문자인 경우 반대이다. |
| \w | 단어문자에 대응된다. 알파벳, 숫자, _를 포함한다. W가 대문자인 경우 반대이다. |
| \n | 줄바꿈에 대응된다. |
| \t | 탭 문자에 대응된다. |
| . | 문자 1개와 대응된다. |
| \\\\^, \\\\$ 등 \\\\와 특수문자 조합| ^, $ 등 특수문자를 그대로 사용하기 위해  |

### 수량 한정자

수량 한정자는 규칙이 반복될 때 사용할 수 있다.

| 수량 한정자 | 역할 |
| --- | --- |
| * | 앞의 표현식이 0회 이상 반복되는 부분과 대응된다. {0,} 과 같은 의미이다.|
| + | 앞의 표현식이 1회 이상 반복되는 부분과 대응된다. {1,}과 같은 의미이다.|
| ? | 앞의 표현식이 0 또는 1회 등장하는 부분과 대응된다. {0,1} 와 같은 의미입니다. |
| {n} | 앞의 표현식이 n번 등장하는 부분과 대응된다. n은 반드시 양의 정수여야 한다.|
| {n, m} | n과 m은 양의 정수이고, n <=m 을 만족해야 한다. 앞의 표현식이 n 이상 m 이하만큼 등장하는 부분에 대응된다. {n, }의 경우 m이 무한대로 간주된다. |

### 문자셋

문자셋은 조건에 포함될 문자를 정의할 때 사용할 수 있다.

예를 들어 [abcd]라는 문자 셋에는 a, b, c, d와 대응된다. 그리고 [a-d]와 같이 하이픈으로 범위를 지정할 경우 [abcd]와 같다.

[^abcd]의 경우는 문자 셋과 같지만 이 문자셋의 범위에 들어간 문자가 대응되지 않고 들어가지 않은 문자와 대응된다.

## 대표적인 정규식 예제

비밀번호 정규식
~~~js
//첫번째 괄호에는 숫자, 두번째 괄호에는 문자, 세번째 괄호에는 특수문자를 포함해야 한다는 조건의 식이 들어가있다. 마지막 괄호에는 숫자 제한의 조건이 들어가있다. 필요한 것만 조합해서 쓰자.
/^.*(?=.*\d)(?=.*[a-zA-Z])(?=.*[!@#$%^&+=])(?=^.{최소자릿수,최대자릿수}$).*$/
~~~

이메일 정규식
~~~js
/^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*.[a-zA-Z]{2,3}$/i
~~~

IPv4 정규식 
~~~js
^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$
~~~

IPv6 정규식 
~~~js
^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$
~~~

